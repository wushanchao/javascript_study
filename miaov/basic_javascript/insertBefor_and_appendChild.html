<!DOCTYPE html>
<html>
<head>
<meta charset="utf8" />
<title>insertBefore和appendChild的使用例子</title>
<script type="text/javascript">
//脚本效果：点击按钮，生成li元素，放入到ul里面的，其它li元素的最前面。
/*
思路就是：得有，按钮点击事件，输入框的内容，ul元素，ul里面的所有li元素。
过程就是：创建一个li元素，li元素的内容由输入框赋值，然后把li元素放入ul里面。
变量依靠：输入框的内容，和ul里面的所有li元素，依靠按钮点击时机来决定。
环境缺憾：insertBefore函数，没有第二个参数会报错。这里要我们手工判断。而appendChild函数没有这个限制。
*/
//面向命令式-----------
// window.onload = function(){
//     var li_content = document.getElementById('li_content'),
//     li_father = document.getElementById('li_father'),
//     create_li = document.getElementById('create_li');

//     create_li.onclick = function(){
//         var new_li = document.createElement('li');
//         var exist_li = li_father.getElementsByTagName('li');
//         new_li.innerHTML = li_content.value;

//         exist_li.length == 0 ? li_father.appendChild(new_li) : li_father.insertBefore(new_li,exist_li[0]);
//     };
// };

//面向函数式-------------
//程序数据结构
function get_struct(isClick){
    //输入框的内容
    var li_content = document.getElementById('li_content').value;
    //ul元素
    var li_father = document.getElementById('li_father');
    //创建li的按钮
    var create_li_button = document.getElementById('create_li');


    if(isClick === "yes"){
        //新创建的li元素
        var new_li = document.createElement('li');
        //ul里面的已存在li元素
        var exist_li = li_father.getElementsByTagName('li');
        return {
            "输入框的内容":li_content,
            "ul元素":li_father,
            "创建li的按钮":create_li_button,
            "新创建的li元素":new_li,
            "ul里面的已存在li元素":exist_li
        };
    }
    
}

//程序运行过程
function run_struct(){
    var data_struct = get_struct("yes");
    data_struct["新创建的li元素"].innerHTML = data_struct["输入框的内容"];
    data_struct["ul里面的已存在li元素"].length == 0 ? data_struct["ul元素"].appendChild(data_struct["新创建的li元素"]) : data_struct["ul元素"].insertBefore(data_struct["新创建的li元素"],data_struct["ul里面的已存在li元素"][0]);

    // console.log(data_struct);
}

window.onload = function(){
    document.getElementById('create_li').onclick = run_struct;
}

//总结：面向函数式写法，程序业务逻辑不考虑语句执行顺序，假设他们就是并行执行。这使得写的代码更靠近自然语言风格；但是，面向命令式的写法，因为其命令结构是严格按照时间顺序，因为你牢记了命令语句执行顺序，不用在代码里判断哪些事件触发了。也就是说，面向函数，多了代码，少了大脑记忆。面向命令，则相反。
</script>
</head>

<body>
<input type="text" id="li_content" />
<input type="button" id="create_li"  value="创建li" />
<ul id="li_father">

</ul>
</body>
</html>